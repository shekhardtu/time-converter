// Real date-fns-tz implementation using native browser APIs
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.dateFnsTz = {}));
}(this, (function (exports) {
  'use strict';

  // Format a date in a specific timezone using native Intl API
  function formatInTimeZone(date, timeZone, formatString) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return 'Invalid Date';
    }

    try {
      // Use Intl.DateTimeFormat for accurate timezone conversion
      const formatter = new Intl.DateTimeFormat('en-US', {
        timeZone: timeZone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });

      const parts = formatter.formatToParts(date);
      const partsObj = {};
      parts.forEach(part => {
        partsObj[part.type] = part.value;
      });

      // Extract components
      const year = partsObj.year;
      const month = partsObj.month;
      const day = partsObj.day;
      const hour = parseInt(partsObj.hour);
      const minute = partsObj.minute;
      const second = partsObj.second;

      // Handle 12-hour format
      const hour12 = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
      const ampm = hour < 12 ? 'AM' : 'PM';

      // Apply format string
      let result = formatString
        .replace(/yyyy/gi, year)
        .replace(/MM/g, month)
        .replace(/dd/gi, day)
        .replace(/HH/g, String(hour).padStart(2, '0'))
        .replace(/hh/g, String(hour12).padStart(2, '0'))
        .replace(/mm/g, minute)
        .replace(/ss/gi, second)
        .replace(/a/gi, ampm);

      return result;
    } catch (error) {
      console.warn('Date formatting error:', error);
      return date.toISOString().slice(0, 19).replace('T', ' ');
    }
  }

  // Convert a date to UTC from a specific timezone
  function zonedTimeToUtc(date, timeZone) {
    if (!(date instanceof Date)) {
      throw new Error('Invalid date');
    }

    try {
      // Create a date string in the source timezone
      const dateString = formatInTimeZone(date, timeZone, 'yyyy-MM-dd HH:mm:ss');
      
      // Parse as if it were UTC, then adjust
      const utcDate = new Date(dateString + ' UTC');
      
      // Get the timezone offset for this date
      const tempDate = new Date(date.getTime());
      const sourceOffset = getTimezoneOffset(tempDate, timeZone);
      const localOffset = tempDate.getTimezoneOffset();
      
      // Calculate the difference
      const offsetDiff = (sourceOffset - localOffset) * 60 * 1000;
      
      return new Date(utcDate.getTime() - offsetDiff);
    } catch (error) {
      console.warn('Zone time to UTC conversion error:', error);
      return date;
    }
  }

  // Convert UTC time to a specific timezone
  function utcToZonedTime(date, timeZone) {
    if (!(date instanceof Date)) {
      throw new Error('Invalid date');
    }

    try {
      // Use Intl API to get the time in target timezone
      const formatter = new Intl.DateTimeFormat('en-CA', {
        timeZone: timeZone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });

      const zonedString = formatter.format(date);
      const zonedDate = new Date(zonedString);
      
      return zonedDate;
    } catch (error) {
      console.warn('UTC to zoned time conversion error:', error);
      return date;
    }
  }

  // Simple format function for dates
  function format(date, formatString) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return 'Invalid Date';
    }

    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hour = date.getHours();
    const minute = String(date.getMinutes()).padStart(2, '0');
    const second = String(date.getSeconds()).padStart(2, '0');

    // Handle 12-hour format
    const hour12 = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
    const ampm = hour < 12 ? 'AM' : 'PM';

    let result = formatString
      .replace(/yyyy/gi, year)
      .replace(/MM/g, month)
      .replace(/dd/gi, day)
      .replace(/HH/g, String(hour).padStart(2, '0'))
      .replace(/hh/g, String(hour12).padStart(2, '0'))
      .replace(/mm/g, minute)
      .replace(/ss/gi, second)
      .replace(/a/gi, ampm);

    return result;
  }

  // Helper function to get timezone offset in minutes
  function getTimezoneOffset(date, timeZone) {
    try {
      const utcDate = new Date(date.getTime());
      const zonedDate = new Date(utcDate.toLocaleString('en-US', { timeZone: 'UTC' }));
      const targetDate = new Date(utcDate.toLocaleString('en-US', { timeZone: timeZone }));
      
      return (zonedDate.getTime() - targetDate.getTime()) / (1000 * 60);
    } catch (error) {
      console.warn('Timezone offset calculation error:', error);
      return 0;
    }
  }

  // Parse common date formats
  function parseDate(dateString) {
    // Try multiple date formats
    const formats = [
      // ISO formats
      /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/,
      /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/,
      /^\d{4}-\d{2}-\d{2}$/,
      // US formats
      /^\d{1,2}\/\d{1,2}\/\d{4}( \d{1,2}:\d{2}(:\d{2})?( [AP]M)?)?$/,
      // European formats
      /^\d{1,2}\.\d{1,2}\.\d{4}( \d{1,2}:\d{2}(:\d{2})?)?$/,
      // Unix timestamp (seconds)
      /^\d{10}$/,
      // Unix timestamp (milliseconds)
      /^\d{13}$/
    ];

    const trimmed = dateString.trim();
    
    // Check for Unix timestamps
    if (/^\d{10}$/.test(trimmed)) {
      return new Date(parseInt(trimmed) * 1000);
    }
    if (/^\d{13}$/.test(trimmed)) {
      return new Date(parseInt(trimmed));
    }

    // Try native Date parsing first
    const nativeDate = new Date(trimmed);
    if (!isNaN(nativeDate.getTime())) {
      return nativeDate;
    }

    // Fallback: try to parse manually
    return new Date(trimmed);
  }

  // Export functions
  exports.formatInTimeZone = formatInTimeZone;
  exports.zonedTimeToUtc = zonedTimeToUtc;
  exports.utcToZonedTime = utcToZonedTime;
  exports.format = format;
  exports.parseDate = parseDate;

})));