// Real date-fns-tz implementation using native browser APIs
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.dateFnsTz = {}));
}(this, (function (exports) {
  'use strict';

  // Format a date in a specific timezone using native Intl API
  function formatInTimeZone(date, timeZone, formatString) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return 'Invalid Date';
    }

    try {
      // Use Intl.DateTimeFormat for accurate timezone conversion
      const formatter = new Intl.DateTimeFormat('en-US', {
        timeZone: timeZone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });

      const parts = formatter.formatToParts(date);
      const partsObj = {};
      parts.forEach(part => {
        partsObj[part.type] = part.value;
      });

      // Extract components
      const year = partsObj.year;
      const month = partsObj.month;
      const day = partsObj.day;
      const hour = parseInt(partsObj.hour);
      const minute = partsObj.minute;
      const second = partsObj.second;

      // Handle 12-hour format
      const hour12 = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
      const ampm = hour < 12 ? 'AM' : 'PM';

      // Apply format string
      let result = formatString
        .replace(/yyyy/gi, year)
        .replace(/MM/g, month)
        .replace(/dd/gi, day)
        .replace(/HH/g, String(hour).padStart(2, '0'))
        .replace(/hh/g, String(hour12).padStart(2, '0'))
        .replace(/mm/g, minute)
        .replace(/ss/gi, second)
        .replace(/a/gi, ampm);

      return result;
    } catch (error) {
      console.warn('Date formatting error:', error);
      return 'Invalid Date';
    }
  }

  // Convert a date to UTC from a specific timezone
  function zonedTimeToUtc(date, timeZone) {
    if (!(date instanceof Date)) {
      throw new Error('Invalid date');
    }

    try {
      // Simple approach: treat the input date as being in the source timezone
      // and convert it to UTC
      
      const year = date.getFullYear();
      const month = date.getMonth();
      const day = date.getDate();
      const hour = date.getHours();
      const minute = date.getMinutes();
      const second = date.getSeconds();
      const ms = date.getMilliseconds();
      
      // Create a date string in the format that represents this time in the source timezone
      const dateString = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')} ${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`;
      
      // Parse this as if it were in the source timezone and get the UTC equivalent
      const tempDate = new Date(dateString);
      
      // Get the offset between the source timezone and UTC at this date
      const utcFormatter = new Intl.DateTimeFormat('en-CA', {
        timeZone: 'UTC',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
      
      const sourceFormatter = new Intl.DateTimeFormat('en-CA', {
        timeZone: timeZone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
      
      // Use a reference date to calculate the offset
      const referenceDate = new Date();
      const utcTime = utcFormatter.format(referenceDate);
      const sourceTime = sourceFormatter.format(referenceDate);
      
      const utcMs = new Date(utcTime).getTime();
      const sourceMs = new Date(sourceTime).getTime();
      const offsetMs = sourceMs - utcMs;
      
      // Apply offset to get UTC time
      return new Date(Date.UTC(year, month, day, hour, minute, second, ms) - offsetMs);
      
    } catch (error) {
      console.warn('Zone time to UTC conversion error:', error);
      return date;
    }
  }

  // Convert UTC time to a specific timezone
  function utcToZonedTime(date, timeZone) {
    if (!(date instanceof Date)) {
      throw new Error('Invalid date');
    }

    try {
      // Use Intl API to get the time in target timezone
      const formatter = new Intl.DateTimeFormat('en-CA', {
        timeZone: timeZone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });

      const zonedString = formatter.format(date);
      const zonedDate = new Date(zonedString);
      
      return zonedDate;
    } catch (error) {
      console.warn('UTC to zoned time conversion error:', error);
      return date;
    }
  }

  // Simple format function for dates
  function format(date, formatString) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      return 'Invalid Date';
    }

    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hour = date.getHours();
    const minute = String(date.getMinutes()).padStart(2, '0');
    const second = String(date.getSeconds()).padStart(2, '0');

    // Handle 12-hour format
    const hour12 = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
    const ampm = hour < 12 ? 'AM' : 'PM';

    let result = formatString
      .replace(/yyyy/gi, year)
      .replace(/MM/g, month)
      .replace(/dd/gi, day)
      .replace(/HH/g, String(hour).padStart(2, '0'))
      .replace(/hh/g, String(hour12).padStart(2, '0'))
      .replace(/mm/g, minute)
      .replace(/ss/gi, second)
      .replace(/a/gi, ampm);

    return result;
  }

  // Parse common date formats
  function parseDate(dateString) {
    const trimmed = dateString.trim();
    
    // Check for Unix timestamps
    if (/^\d{10}$/.test(trimmed)) {
      return new Date(parseInt(trimmed) * 1000);
    }
    if (/^\d{13}$/.test(trimmed)) {
      return new Date(parseInt(trimmed));
    }

    // Try native Date parsing first
    const nativeDate = new Date(trimmed);
    if (!isNaN(nativeDate.getTime())) {
      return nativeDate;
    }

    // Fallback: try to parse manually
    return new Date(trimmed);
  }

  // Export functions
  exports.formatInTimeZone = formatInTimeZone;
  exports.zonedTimeToUtc = zonedTimeToUtc;
  exports.utcToZonedTime = utcToZonedTime;
  exports.format = format;
  exports.parseDate = parseDate;

})));